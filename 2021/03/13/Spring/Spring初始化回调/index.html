
<!DOCTYPE html>
<html lang="">


<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020"/>
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="/js/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="Spring," />
  

  
    <meta name="description" content="一个专注一coding的网站。提供丰富编程知识，包括Spring、Java、EmberJS、SpringBoot等等技术。" />
  
  
  <link rel="icon" type="image/x-icon" href="/image/favicon.ico">
  <title>Spring初始化回调 [ Keep Coding ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
<meta name="generator" content="Hexo 5.0.2"><link rel="alternate" href="/atom.xml" title="Keep Coding" type="application/atom+xml">
</head>

<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    <img class="avatar" src="/image/favicon.ico">
    <span class="title">Keep Coding</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            <li class="pure-menu-item"><a href="/" class="pure-menu-link">首页</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/archives" class="pure-menu-link">归档</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/tags" class="pure-menu-link">标签</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/search" class="pure-menu-link">搜索</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/about" class="pure-menu-link">关于</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/atom.xml" class="pure-menu-link">订阅</a></li>
          
      
  </ul>
   
</nav>
  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        Spring初始化回调
      </h1>
      <span>
        
        <time class="time" datetime="2021-03-13T09:36:16.000Z">
        2021-03-13
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>
      </span>
    </span>
      <span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
      <span class="slash">/</span>
      <span class="read">阅读耗时 15 分钟</span>
    </header>

    <div class="post-content">
      <p>Spring框架提供了多种方式控制bean初始化的过程，开发者可以自定义初始化的逻辑。</p>
<p>有如下几种自定义bean初始化逻辑的方式：</p>
<ol>
<li>使用<code>@PostConstruct</code>注解</li>
<li>自定义初始化方法，比如<code>@Bean(initMethod = &quot;method1&quot;)</code></li>
<li>实现<code>InitializingBean</code>接口的<code>afterPropertiesSet()</code>方法</li>
<li>实现<code>SmartInitializingSingleton</code>接口的<code>afterSingletonsInstantiated()</code>方法</li>
</ol>
<p>这四种方式都可以用于自定义bean的初始化。但是每种方法执行的时机不太一样，通过Spring源码来给大家逐一介绍。</p>
<p>首先自定义一个bean，分别实现上述4中方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ubuntuvim.spring.createbean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.SmartInitializingSingleton;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.RootBeanDefinition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证不同方式初始化回调的执行顺序：</span></span><br><span class="line"><span class="comment"> * 0. 执行初始化回调BeanPostProcessor.postProcessBeforeInitialization()方法</span></span><br><span class="line"><span class="comment"> * 1. 执行初始化回调<span class="doctag">@PostConstruct</span>注解定义的方法</span></span><br><span class="line"><span class="comment"> * 2. 执行初始化回调InitializingBean.afterPropertiesSet()方法</span></span><br><span class="line"><span class="comment"> * 3. 执行初始化回调<span class="doctag">@Bean</span>(initMethod = &quot;beanInit&quot;)定义的方法</span></span><br><span class="line"><span class="comment"> * 4. 执行初始化回调BeanPostProcessor.postProcessAfterInitialization()方法</span></span><br><span class="line"><span class="comment"> * 5. 执行初始化回调SmartInitializingSingleton.afterSingletonsInstantiated()方法，</span></span><br><span class="line"><span class="comment"> *         此回调是在bean实例化和初始化完成之后执行的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: ubuntuvim</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/18 上午1:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitCallbackBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">SmartInitializingSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果一个类中多个方法都使用<span class="doctag">@PostConstruct</span>注解声明，则会根据方法名按照字母升序顺序执行。</span></span><br><span class="line"><span class="comment">     * 比如init()和afterPropertiesSet()都加了注解，那么先执行afterPropertiesSet()方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行初始化回调@PostConstruct注解定义的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行初始化回调@PostConstruct注解定义的方法init2()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果用户在afterPropertiesSet()方法上也使用了<span class="doctag">@PostConstruct</span>注解，此方法在后置处理器中会先被执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> InitDestroyAnnotationBeanPostProcessor#postProcessBeforeInitialization(java.lang.Object, java.lang.String)</span></span><br><span class="line"><span class="comment">     * 然后在执行初始化回调接口InitializingBean时不会再次执行。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AbstractAutowireCapableBeanFactory#invokeInitMethods(String, Object, RootBeanDefinition)</span></span><br><span class="line"><span class="comment">     * 也就是说同时在回调接口InitializingBean上同时使用<span class="doctag">@PostConstruct</span>注解只会执行一次，但是可以改变方法的执行时机，</span></span><br><span class="line"><span class="comment">     * 比如本类中init()和afterPropertiesSet()都加了<span class="doctag">@PostConstruct</span>注解，那么先执行afterPropertiesSet()方法，</span></span><br><span class="line"><span class="comment">     * 如果afterPropertiesSet()方法不加<span class="doctag">@PostConstruct</span>注解，那么会先执行init()方法，再执行afterProperties()方法。</span></span><br><span class="line"><span class="comment">     * 因为<span class="doctag">@PostConstruct</span>注解优先于回调接口InitializingBean执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果<span class="doctag">@Bean</span>注解中自定义的方法也使用<span class="doctag">@PostConstruct</span>注解声明，那么这个方法会重复执行。</span></span><br><span class="line"><span class="comment">     * 1. 后置处理器处理<span class="doctag">@PostConstruct</span>注解方法的时候执行一次，</span></span><br><span class="line"><span class="comment">     * 2. 执行自定义的方法的时候也执行一次</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Bean</span>(initMethod = &quot;afterPropertiesSet&quot;)</span></span><br><span class="line"><span class="comment">     * 如果自定义的方法和InitializingBean的回调方法一致。</span></span><br><span class="line"><span class="comment">     * afterPropertiesSet()方法会执行一次，只执行InitializingBean的回调，不会在执行自定义方法的回调。</span></span><br><span class="line"><span class="comment">     * 原因可以看Spring源码，位置：</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AbstractAutowireCapableBeanFactory#invokeInitMethods(String, Object, RootBeanDefinition)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Bean</span>(initMethod = &quot;initBean&quot;)</span></span><br><span class="line"><span class="comment">     * 如果自定义的方法也使用了<span class="doctag">@PostConstruct</span>声明，那么initBean()会执行两次。</span></span><br><span class="line"><span class="comment">     * 1. 后置处理器处理<span class="doctag">@PostConstruct</span>注解方法的时候执行一次，</span></span><br><span class="line"><span class="comment">     * 2. 执行自定义的方法的时候也执行一次</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 总结一句话，InitializingBean.afterPropertiesSet()方法只会执行一次。</span></span><br><span class="line"><span class="comment">     *             <span class="doctag">@PostConstruct</span> 声明的方法都会执行，不管有几个，执行顺序按照方法名升序执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    @PostConstruct</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行初始化回调InitializingBean.afterPropertiesSet()方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterSingletonsInstantiated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行初始化回调SmartInitializingSingleton.afterSingletonsInstantiated()方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">beanInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行初始化回调@Bean(initMethod = \&quot;beanInit\&quot;)定义的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>@Bean</code>方式把此类注入到Spring容器中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;beanInit&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InitCallbackBean <span class="title">initCallbackBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InitCallbackBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先运行看结果是怎么样的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">执行初始化回调@PostConstruct注解定义的init方法</span><br><span class="line">执行初始化回调@Bean(initMethod = &quot;beanInit&quot;)定义的方法，并且此方法也使用了@PostConstruct注解</span><br><span class="line">执行初始化回调@PostConstruct注解定义的方法init2()</span><br><span class="line">执行初始化回调InitializingBean.afterPropertiesSet()方法</span><br><span class="line">执行初始化回调@Bean(initMethod = &quot;beanInit&quot;)定义的方法，并且此方法也使用了@PostConstruct注解</span><br><span class="line">执行初始化回调SmartInitializingSingleton.afterSingletonsInstantiated()方法</span><br></pre></td></tr></table></figure>
<p>通过运行结果分析，可以看到使用<code>@PostConstruct</code>注解的方法会第一个执行，<code>beanInit</code>方法同时使用了<code>@PostConstruct</code>注解，并且同时在<code>@Bean</code>中也指定成bean自定义的初始化方法，所以这个方法执行了两次。如果同一个类中有个多个方法都使用了<code>@PostConstruct</code>注解，那么这些被注解的方法都会被执行，但是执行的顺序不一定是方法在类中的代码顺序。</p>
<p>做点好玩的事情，在<code>afterPropertiesSet()</code>方法上也使用<code>@PostConstruct</code>注解，再运行看看结果是怎么样，会不会执行两遍？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">执行初始化回调@PostConstruct注解定义的init方法</span><br><span class="line">执行初始化回调InitializingBean.afterPropertiesSet()方法</span><br><span class="line">执行初始化回调@Bean(initMethod = &quot;beanInit&quot;)定义的方法，并且此方法也使用了@PostConstruct注解</span><br><span class="line">执行初始化回调@PostConstruct注解定义的方法init2()</span><br><span class="line">执行初始化回调@Bean(initMethod = &quot;beanInit&quot;)定义的方法，并且此方法也使用了@PostConstruct注解</span><br><span class="line">执行初始化回调SmartInitializingSingleton.afterSingletonsInstantiated()方法</span><br></pre></td></tr></table></figure>
<p>这个就比较有意思了，可以看到<code>afterPropertiesSet()</code>方法只执行了一遍。</p>
<p>这几种初始化方法执行顺序是怎么设定的呢？为何使用<code>@PostConstruct</code>注解的方法可以执行多次，而<code>afterPropertiesSet()</code>方法却执行一次呢？<br>带这些疑问，我们阅读Spring源码，从源码中找答案。</p>
<h3 id="不同初始化方式的执行时机"><a href="#不同初始化方式的执行时机" class="headerlink" title="不同初始化方式的执行时机"></a>不同初始化方式的执行时机</h3><p>这些初始化方法都是在有bean实例之后执行的，我们可以大概的猜测到这些初始化回调应该是在Spring框架完成bean实例化，进行属性填充的时候执行的。</p>
<blockquote>
<p>如果你对Spring框架bean的实例化、初始化不是很了解的请看之前的系列博客：<a target="_blank" rel="noopener" href="https://www.toutiao.com/i6887194772914733571">https://www.toutiao.com/i6887194772914733571</a></p>
</blockquote>
<p>直接打开如下类方法，</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</span><br></pre></td></tr></table></figure>
<p>这个方法是Spring容器非常核心的方法，它处理了很多事情：单例实例化、填充属性、执行初始化回调、注册销毁回调方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Instantiate the bean.</span></span><br><span class="line">  BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    <span class="comment">// 从缓存中查询，如果是bean定义是一个bean工厂实例可以直接拿到。</span></span><br><span class="line">    instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 普通bean，根据bean定义创建bean实例，并包装成BeanWrapper返回</span></span><br><span class="line">    instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取经过jdk1.8的Optional类包装过的非空对象</span></span><br><span class="line">  <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">  <span class="comment">// 获取bean的class类型</span></span><br><span class="line">  Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">  <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">    mbd.resolvedTargetType = beanType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">  <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行后置处理器接口MergedBeanDefinitionPostProcessor，bean实例化之后，就可以通过反射获取到类或者属性上的注释信息</span></span><br><span class="line">        <span class="comment">// 处理@Resource、@Autowired、@Value注解的定义信息，并把这些注解的定义信息放在缓存中。待后续属性填充的时候使用。</span></span><br><span class="line">        <span class="comment">// 如果有则吧注解信息转换成AutowiredFieldElement对象或者AutowiredMethodElement对象或者ResourceElement对象</span></span><br><span class="line">        <span class="comment">// 实现类有：AutowiredAnnotationBeanPostProcessor、CommonAnnotationBeanPostProcessor等</span></span><br><span class="line">        applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                        <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">  <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">  <span class="comment">// 单例bean &amp;&amp; 允许循环依赖 &amp;&amp; bean正在被创建</span></span><br><span class="line">  <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                                    isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">  <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                   <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 执行后置处理器SmartInstantiationAwareBeanPostProcessor的getEarlyBeanReference()方法尝试获取一个早期的引用。</span></span><br><span class="line"><span class="comment">             * 并加入的单例工厂缓存中</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@see</span> DefaultSingletonBeanRegistry#addSingletonFactory(String, ObjectFactory)</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@see</span> #getEarlyBeanReference</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">  <span class="comment">// 初始化bean实例，填充属性，注入依赖（@Autowired，@Resource，@Value）注解的属性</span></span><br><span class="line">  Object exposedObject = bean;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">             执行bean的初始化回调方法以及执行后置处理器的初始化方法，包括：</span></span><br><span class="line"><span class="comment">            一，执行Aware接口 ，包括BeanFactoryAware，BeanClassLoaderAware，BeanNameAware</span></span><br><span class="line"><span class="comment">                注意：ApplicationContext的注入是在另外一个后置处理器ApplicationContextAwareProcessor中执行。</span></span><br><span class="line"><span class="comment">              二，执行bean初始化回调，包括：</span></span><br><span class="line"><span class="comment">                0. 执行初始化回调BeanPostProcessor.postProcessBeforeInitialization()方法</span></span><br><span class="line"><span class="comment">                1. 执行初始化回调<span class="doctag">@PostConstruct</span>注解定义的方法</span></span><br><span class="line"><span class="comment">                 2. 执行初始化回调InitializingBean.afterPropertiesSet()方法</span></span><br><span class="line"><span class="comment">                3. 执行初始化回调<span class="doctag">@Bean</span>(initMethod = &quot;beanInit&quot;)定义的初始化方法beanInit()</span></span><br><span class="line"><span class="comment">                 4. 执行初始化回调BeanPostProcessor.postProcessAfterInitialization()方法</span></span><br><span class="line"><span class="comment">                5. 执行初始化回调SmartInitializingSingleton.afterSingletonsInstantiated()方法</span></span><br><span class="line"><span class="comment">                按照上述执行顺序执行</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">    exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">        mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 循环依赖检查</span></span><br><span class="line">  <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">        exposedObject = earlySingletonReference;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">        String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">        Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">        <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">            actualDependentBeans.add(dependentBean);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                                                     <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                                                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                                                     <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                                                     <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                                                     <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                                                     <span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register bean as disposable.</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 注册bean销毁回调方法，这个方法和前面的initializeBean()方法是对应的。通常情况下初始化方法和销毁方法是同时出现的。</span></span><br><span class="line"><span class="comment">             * 比如回调DisposableBean接口的destroy()方法，需要注意的是这里只是注册，并不会执行销毁回调方法。</span></span><br><span class="line"><span class="comment">             * 销毁方法的调用是在手动执行容器的关闭方法的时候：</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@see</span> org.springframework.context.support.AbstractApplicationContext#close()</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@see</span> AbstractBeanFactory#registerDisposableBeanIfNecessary(String, Object, RootBeanDefinition)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">    registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">      mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 回到调用处：</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> #createBean(String, RootBeanDefinition, Object[])</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>initializeBean(beanName, exposedObject, mbd)</code>这行是本次我们需要关注的，所有的初始化回调都是在这个方法中执行的。<br>进入这个方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize the given bean instance, applying factory callbacks</span></span><br><span class="line"><span class="comment">     * as well as init methods and bean post processors.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Called from &#123;<span class="doctag">@link</span> #createBean&#125; for traditionally defined beans,</span></span><br><span class="line"><span class="comment">     * and from &#123;<span class="doctag">@link</span> #initializeBean&#125; for existing bean instances.</span></span><br><span class="line"><span class="comment">     * 本方法的作用有</span></span><br><span class="line"><span class="comment">     * 一，执行Aware接口 ，包括BeanFactoryAware，BeanClassLoaderAware，BeanNameAware</span></span><br><span class="line"><span class="comment">   *         注意：ApplicationContext的注入是在另外一个后置处理器ApplicationContextAwareProcessor中执行。</span></span><br><span class="line"><span class="comment">     * 二，执行bean初始化回调，包括：</span></span><br><span class="line"><span class="comment">     *         0. 执行初始化回调BeanPostProcessor.postProcessBeforeInitialization()方法</span></span><br><span class="line"><span class="comment">     *         1. 执行初始化回调<span class="doctag">@PostConstruct</span>注解定义的方法</span></span><br><span class="line"><span class="comment">     *         2. 执行初始化回调InitializingBean.afterPropertiesSet()方法</span></span><br><span class="line"><span class="comment">     *         3. 执行初始化回调<span class="doctag">@Bean</span>(initMethod = &quot;beanInit&quot;)定义的方法</span></span><br><span class="line"><span class="comment">     *         4. 执行初始化回调BeanPostProcessor.postProcessAfterInitialization()方法</span></span><br><span class="line"><span class="comment">     *         5. 执行初始化回调SmartInitializingSingleton.afterSingletonsInstantiated()方法</span></span><br><span class="line"><span class="comment">     * 按照上述执行顺序执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName the bean name in the factory (for debugging purposes)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean the new bean instance we may need to initialize</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mbd the bean definition that the bean was created with</span></span><br><span class="line"><span class="comment">     * (can also be &#123;<span class="doctag">@code</span> null&#125;, if given an existing bean instance)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the initialized bean instance (potentially wrapped)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> BeanNameAware</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> BeanClassLoaderAware</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> BeanFactoryAware</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #applyBeanPostProcessorsBeforeInitialization</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #invokeInitMethods</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #applyBeanPostProcessorsAfterInitialization</span></span><br><span class="line"><span class="comment">     * 方法调用处：</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #doCreateBean(String, RootBeanDefinition, Object[]) </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果bean实现了XxxAware接口，则调用这些接口的setXxx()方法</span></span><br><span class="line">  <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">      invokeAwareMethods(beanName, bean);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;, getAccessControlContext());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    invokeAwareMethods(beanName, bean);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行后置处理器的postProcessorBeforeInitialization()方法</span></span><br><span class="line"><span class="comment">         * 这里会首先执行第一个初始化回调<span class="doctag">@PostConstruct</span>声明的方法，是这个类实现的</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor#postProcessBeforeInitialization</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  Object wrappedBean = bean;</span><br><span class="line">  <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">    wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行InitializingBean接口和自定义的初始化方法（@Bean(initMethod = &quot;beanInit&quot;))</span></span><br><span class="line">    invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">      (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">      beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行后置处理器的postProcessorAfterInitialization()方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 完成各种初始化回调方法，回到调用处：</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> #doCreateBean(String, RootBeanDefinition, Object[]) </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此方法中就可以看到初始化回调的执行顺序，首先是<code>applyBeanPostProcessorsBeforeInitialization()</code>这个方法里面会执行<code>@PostContruct</code>注解的方法，是通过后置处理器实现的。</p>
<p>其次是<code>invokeInitMethods()</code>方法，这个方法内会执行的<code>InitializingBean</code>接口的<code>afterPropertiesSet()</code>方法，以及执行在<code>@Bean</code>注解中定义的初始化方法。</p>
<p>最后的是<code>applyBeanPostProcessorsAfterInitialization()</code>方法，这个方法会执行后置处理器接口<code>SmartInitializingSingleton</code>的<code>afterSingletonsInstantiated()</code>方法。</p>
<p>到此解决了一个疑问，不同类型的回调的执行顺序就是在上述代码中设定的。</p>
<h3 id="PostConstruct注解方法的执行"><a href="#PostConstruct注解方法的执行" class="headerlink" title="PostConstruct注解方法的执行"></a>PostConstruct注解方法的执行</h3><p>此注解执行的处理类是<code>org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor#postProcessBeforeInitialization</code>。</p>
<p>进入此方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 获取@PostConstruct注解定义的方法</span></span><br><span class="line">  LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    metadata.invokeInitMethods(bean, beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex.getTargetException());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;Failed to invoke init method&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法逻辑比较简单，<code>findLifecycleMetadata()</code>把使用了注解<code>@PostConstruct</code>定义的方法包装成<code>LifecycleMetadata</code>，然后在<code>invokeInitMethods()</code>方法中执行。这两个方法的最底层都是通过反射实现的。</p>
<p><strong>回到前面的疑问，<code>@PostConstruct</code>注解的方法为何可以有多个？并且无法控制方法的执行顺序？</strong></p>
<p>第二个疑问，进入<code>findLifecycleMetadata()</code>方法的实现就知道了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> LifecycleMetadata <span class="title">findLifecycleMetadata</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.lifecycleMetadataCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Happens after deserialization, during destruction...</span></span><br><span class="line">    <span class="keyword">return</span> buildLifecycleMetadata(clazz);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line">  LifecycleMetadata metadata = <span class="keyword">this</span>.lifecycleMetadataCache.get(clazz);</span><br><span class="line">  <span class="keyword">if</span> (metadata == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.lifecycleMetadataCache) &#123;</span><br><span class="line">      metadata = <span class="keyword">this</span>.lifecycleMetadataCache.get(clazz);</span><br><span class="line">      <span class="keyword">if</span> (metadata == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过反射获取到使用@PostConstruct注解的方法，并包装成LifecycleMetadata</span></span><br><span class="line">        metadata = buildLifecycleMetadata(clazz);</span><br><span class="line">        <span class="keyword">this</span>.lifecycleMetadataCache.put(clazz, metadata);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> metadata;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法还不是真正实现的地方，还需要继续进入<code>buildLifecycleMetadata()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> LifecycleMetadata <span class="title">buildLifecycleMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!AnnotationUtils.isCandidateClass(clazz, Arrays.asList(<span class="keyword">this</span>.initAnnotationType, <span class="keyword">this</span>.destroyAnnotationType))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.emptyLifecycleMetadata;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List&lt;LifecycleElement&gt; initMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;LifecycleElement&gt; destroyMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  Class&lt;?&gt; targetClass = clazz;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;LifecycleElement&gt; currInitMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> List&lt;LifecycleElement&gt; currDestroyMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反射获取到目标类的方法列表，然后遍历这些方法判断是否有使用@PostConstruct注解</span></span><br><span class="line">    <span class="comment">// 如果有则保存到currInitMethods</span></span><br><span class="line">    ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.initAnnotationType != <span class="keyword">null</span> &amp;&amp; method.isAnnotationPresent(<span class="keyword">this</span>.initAnnotationType)) &#123;</span><br><span class="line">        LifecycleElement element = <span class="keyword">new</span> LifecycleElement(method);</span><br><span class="line">        currInitMethods.add(element);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Found init method on class [&quot;</span> + clazz.getName() + <span class="string">&quot;]: &quot;</span> + method);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.destroyAnnotationType != <span class="keyword">null</span> &amp;&amp; method.isAnnotationPresent(<span class="keyword">this</span>.destroyAnnotationType)) &#123;</span><br><span class="line">        currDestroyMethods.add(<span class="keyword">new</span> LifecycleElement(method));</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Found destroy method on class [&quot;</span> + clazz.getName() + <span class="string">&quot;]: &quot;</span> + method);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    initMethods.addAll(<span class="number">0</span>, currInitMethods);</span><br><span class="line">    destroyMethods.addAll(currDestroyMethods);</span><br><span class="line">    targetClass = targetClass.getSuperclass();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (targetClass != <span class="keyword">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (initMethods.isEmpty() &amp;&amp; destroyMethods.isEmpty() ? <span class="keyword">this</span>.emptyLifecycleMetadata :</span><br><span class="line">          <span class="keyword">new</span> LifecycleMetadata(clazz, initMethods, destroyMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在继续进入<code>doWithLocalMethods()</code>方法， 这个方法还做了一层封装。核心的方法实现在<code>getDeclaredMethods()</code>，这个方法里面最主要一句代码<code>Method[] declaredMethods = clazz.getDeclaredMethods();</code>，这行代码只要用过反射的应该很熟悉。直接通过class获取到类内部的所有方法（包括继承过来的方法）。<code>clazz.getDeclaredMethods()</code>方法返回的是一个数组，里面的元素没有提供排序的入口。所以最终执行的<code>@PostConstruct</code>注解的方法也不知道顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWithLocalMethods</span><span class="params">(Class&lt;?&gt; clazz, MethodCallback mc)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 通过反射获取目标类内部的方法</span></span><br><span class="line">  Method[] methods = getDeclaredMethods(clazz, <span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      mc.doWith(method);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Not allowed to access method &#x27;&quot;</span> + method.getName() + <span class="string">&quot;&#x27;: &quot;</span> + ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到所有注解的方法之后，直接通过<code>for</code>循环逐个执行。从入口一直到这里执行注解方法的过程中，没有对方法做任何的过滤，直接<code>for</code>循环遍历执行。所以同一个类是支持在多个方法上使用<code>@PostConstruct</code>注解，并且会把所有使用了注解的方法执行。</p>
<h3 id="InitializingBean接口执行"><a href="#InitializingBean接口执行" class="headerlink" title="InitializingBean接口执行"></a>InitializingBean接口执行</h3><p><code>@PostConstruct</code>注解的方法执行完毕之后，回到<code>initializeBean()</code>方法中，继续往下执行<code>invokeInitMethods()</code>方法。这个方法中就会执行所有实现了<code>InitializingBean</code>接口的实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line">  <span class="comment">// 使用@PostConstruct定义的方法在解析bean定义时候会初始化到bean定义属性externallyManagedInitMethods里面</span></span><br><span class="line">  <span class="comment">// 如果用户在afterPropertiesSet()方法上也使用了@PostConstruct注解则不会再执行。</span></span><br><span class="line">  <span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">&quot;afterPropertiesSet&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Invoking afterPropertiesSet() on bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">          ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">        <span class="keyword">throw</span> pae.getException();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; bean.getClass() != NullBean.class) &#123;</span><br><span class="line">    <span class="comment">// 获取自定义的初始化方法，比如@Bean(initMethod = &quot;beanInit&quot;)，自定义的初始化方法就是beanInit()</span></span><br><span class="line">    String initMethodName = mbd.getInitMethodName();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;</span><br><span class="line">        <span class="comment">// 排除自定义的初始化方法也是afterPropertiesSet()方法，避免重复执行</span></span><br><span class="line">        !(isInitializingBean &amp;&amp; <span class="string">&quot;afterPropertiesSet&quot;</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">        <span class="comment">// 使用@PostConstruct定义的方法在解析bean定义时候会初始化到bean定义属性externallyManagedInitMethods里面</span></span><br><span class="line">        <span class="comment">// 方式初始化方法重复执行，如果在前面执行@PostConstruct方法已经执行过同名方法则不再执行</span></span><br><span class="line">        <span class="comment">// 另外，如果@Bean自定义的回调方法也是afterPropertiesSet()方法，</span></span><br><span class="line">        <span class="comment">// 这里不会再次执行，因为在前面InitializingBean接口方法已经执行过</span></span><br><span class="line">        !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">      invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法的逻辑也很明了，分为两部分：前面部分就是判断当前bean是否实现了接口，如果是就直接执行接口的<code>afterPropertiesSet()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((InitializingBean) bean).afterPropertiesSet();    </span><br></pre></td></tr></table></figure>

<p>但是在执行之前有一段校验逻辑<code>mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;)</code>，这一行代码就是用于判断，如果前面使用<code>@PostConstruct</code>注解声明的方法中已经包含了<code>afterPropertiesSet</code>则不会在执行这个方法。避免重复执行。这也就是为何演示例子中<code>afterPropertiesSet()</code>方法只会执行一遍的原因。并且是在执行<code>@PostConstruct</code>方法列表的时候就执行了。</p>
<p>这个方法的第二部分也同样有校验。在执行<code>@Bean</code>自定义的初始化方法之前也是先判断<code>afterPropertiesSet()</code>方法是否已经执行过。避免<code>@Bean(initMethod = &quot;afterPropertiesSet&quot;)</code>这种情况导致方法重复执行。</p>
<p><code>@Bean</code>中自定义的方法的执行详细逻辑就不贴代码了，最底层也是通过反射执行的。</p>
<p>好了，完成了<code>@Bean</code>自定义方法和<code>InitializingBean</code>接口方法的执行之后，接着回到<code>initializeBean()</code>方法中，继续往下执行<code>applyBeanPostProcessorsAfterInitialization()</code>方法，这个方法主要是执行后置处理器的<code>postProcessAfterInitialization()</code>方法的。和本篇主题无关，不过多解释。</p>
<h3 id="afterSingletonsInstantiated-方法执行"><a href="#afterSingletonsInstantiated-方法执行" class="headerlink" title="afterSingletonsInstantiated()方法执行"></a>afterSingletonsInstantiated()方法执行</h3><p>最后就是<code>SmartInitializingSingleton.afterSingletonsInstantiated()</code>方法的执行，此方法的执行和前面的初始化回调不在一个地方，这个方法是在bean实例化完成，并且完成了属性填充之后。才执行的，代码位置在：<code>org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化所有除了Spring内部的单例（懒加载的、抽象类、非单例的除外）</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 省略与本篇无关代码</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// =========================================================================</span></span><br><span class="line">  <span class="comment">// 到此单例bean都已经实例化完毕，紧接着可以对实例对象做一些增强，通过BeanPostProcessor后置处理器增强</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">  <span class="comment">// 判断是否有实现了SmartInittializingSingleton的实现类，通常是Spring内部的实现类，也是Spring提供的一个很重要的扩展点</span></span><br><span class="line">  <span class="comment">// 初始化操作执行顺序：@PostConstruct是最先被执行的，然后是InitializingBean，最后是SmartInitializingSingleton</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    Object singletonInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">      <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">      <span class="comment">// bean实例化后调用bean的afterSingletonsInstantiated方法，用户可以实现SmartInitializingSingleton接口，</span></span><br><span class="line">      <span class="comment">// 在所有bean实例化后做一些自定义的操作，比如重置实例的某些属性，但是要注意只能处理非懒加载的单例bean</span></span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">          smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处也是一个后置处理器，<strong>这个是Spring框架提供的一个对所有bean初始化的入口</strong>。前面的初始化回调都是针对某一个bean做得处理。这个是最大的不同之处。只要你实现了此接口方法<code>afterSingletonsInstantiated()</code>，所有的bean在初始化完成之后执行此方法逻辑。</p>
<p>好了，到此总算是把所有的初始化回调介绍完毕。你是否搞懂了呢？？</p>

    </div>

      
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2021/02/25/%E6%9E%B6%E6%9E%84/DDD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="DDD学习笔记">
          DDD学习笔记
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/2021/03/18/Java/Java%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="prev" title="Java面试题">
            Java面试题
          </a>
          <span>〉</span>
        
      </div>
    </div>
  
  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA"><span class="toc-text">不同初始化方式的执行时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PostConstruct%E6%B3%A8%E8%A7%A3%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-text">PostConstruct注解方法的执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InitializingBean%E6%8E%A5%E5%8F%A3%E6%89%A7%E8%A1%8C"><span class="toc-text">InitializingBean接口执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#afterSingletonsInstantiated-%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C"><span class="toc-text">afterSingletonsInstantiated()方法执行</span></a></li></ol>
  </div>


  </div>
</div>


<div class="copyright">
    <span>本作品采用</span>
    <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>
<div class="share">

</div>
<div class="post-container">
    <article class="post">
      <div id="container"></div>
    </article>
</div>


<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="/js/gitment.browser.js"></script>

<script>
var gitment = new Gitment({
  id: 'Spring初始化回调', // 可选。默认为 location.href
  owner: 'ubuntuvim',
  repo: 'ubuntuvim.github.io',
  oauth: {
    client_id: '48b3df0bf4ba1743e0a3',
    client_secret: '4cf1e76de9e18b9ad0def477c36ab22059b152c8'
  }
});
gitment.render('container');
</script>



    </div>

    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <a class="bottom-item" href="http://xcoding.tech/">首页</a> |
        <a class="bottom-item" href="http://xcoding.tech/" target="_blank">主站</a> |
        <a class="bottom-item" href="https://github.com/ubuntuvim" target="_blank">GitHub</a> |
        <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> |
        <a class="bottom-item" href="https://github.com/KevinOfNeu/hexo-theme-xoxo" target="_blank">Theme xoxo</a>
    </div>
</footer>


  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>


<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

  
  <!-- scripts list from theme config.yml -->
  
    <script src="/js/zepto.min.js"></script>
  
    <script src="/js/gitment.browser.js"></script>
  


<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



</body>
</html>
