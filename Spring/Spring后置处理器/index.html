
<!DOCTYPE html>
<html lang="">


<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#303030"/>
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="/js/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="Java,Spring," />
  

  
    <meta name="description" content="一个专注一coding的网站。提供丰富编程知识，包括Spring、Java、EmberJS、SpringBoot等等技术。" />
  
  
  <link rel="icon" type="image/x-icon" href="/image/favicon.ico">
  <title>Spring后置处理器</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
<meta name="generator" content="Hexo 5.0.2"><link rel="alternate" href="/atom.xml" title="null" type="application/atom+xml">
</head>

<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
  <!--
    <img class="avatar" src="/image/logo1.png">
-->
    <svg t="1696736567728" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3064" width="40px" height="50px"><path d="M203.8 255.1h619c12.7 0 23 10.4 23 23v391.1c0 12.7-10.4 23-23 23h-619c-12.7 0-23-10.4-23-23V278.1c0-12.7 10.3-23 23-23z" fill="#5B79FB" p-id="3065"></path><path d="M215.3 300.7h596v320h-596z" fill="#FFFFFF" p-id="3066"></path><path d="M499.1 640.6h28.3v28.3h-28.3z" fill="#FF7E71" p-id="3067"></path><path d="M180.8 692.1h665l115.5 49.2h-896z" fill="#5B79FB" p-id="3068"></path><path d="M65.3 741.3h896v12.9c0 9.1-7.5 16.6-16.6 16.6H81.9c-9.1 0-16.6-7.5-16.6-16.6v-12.9z" fill="#5B79FB" p-id="3069"></path><path d="M422.8 750.3h181v11.5h-181z" fill="#FF7E71" p-id="3070"></path><path d="M196.7 696.1h62.2c-3.2 1.9-6.3 3.8-9.4 5.7h-64.4c3.9-1.9 7.8-3.8 11.6-5.7zM310.7 696.1h62.2l-5.1 5.7h-64.5c2.4-1.9 4.9-3.8 7.4-5.7zM424.7 696.1h62.2c-0.2 1.9-0.5 3.8-0.9 5.7h-64.6c1.2-1.9 2.3-3.8 3.3-5.7zM538.8 696.1H601c1.1 1.9 2.3 3.8 3.3 5.7h-64.6c-0.2-1.9-0.6-3.8-0.9-5.7zM652.8 696.1H715c2.6 1.9 5.1 3.8 7.6 5.7h-64.5c-1.7-1.9-3.5-3.8-5.3-5.7zM766.9 696.1h62.2c4 1.9 7.9 3.8 11.8 5.7h-64.6c-3.1-1.9-6.2-3.8-9.4-5.7zM176.7 705.9h66.1c-3.1 1.9-6.3 3.8-9.4 5.7H165c3.8-1.9 7.8-3.8 11.7-5.7zM298 705.9h66.1c-1.7 1.9-3.5 3.8-5.1 5.7h-68.5c2.4-1.9 5-3.8 7.5-5.7zM419.3 705.9h66.2l-0.9 5.7h-68.5c1-1.9 2.1-3.8 3.2-5.7zM540.5 705.9h66.2l3.3 5.7h-68.5c-0.3-1.9-0.6-3.8-1-5.7zM661.9 705.9H728c2.5 1.9 5.1 3.8 7.5 5.7h-68.4c-1.7-1.9-3.5-3.8-5.2-5.7zM783.2 705.9h66.3l11.7 5.7h-68.5c-3.1-1.9-6.3-3.8-9.5-5.7zM156.6 715.8h70.1c-3.2 1.9-6.2 3.8-9.4 5.7H145c3.8-1.9 7.6-3.8 11.6-5.7zM285.1 715.8h70.2c-1.8 1.9-3.4 3.8-5.1 5.7h-72.4c2.4-1.9 4.8-3.8 7.3-5.7zM413.7 715.8h70.2c-0.4 1.9-0.6 3.8-0.9 5.7h-72.5c1.1-1.9 2.1-3.8 3.2-5.7zM542.3 715.8h70.2c1 1.9 2.2 3.8 3.3 5.7h-72.5c-0.3-1.9-0.7-3.8-1-5.7zM670.9 715.8h70.2c2.4 1.9 5 3.8 7.5 5.7h-72.4c-1.8-1.9-3.6-3.8-5.3-5.7zM799.5 715.8h70.2l11.7 5.7h-72.5c-3-1.9-6.3-3.8-9.4-5.7zM136.5 725.6H890c4 1.9 7.8 3.8 11.7 5.7h-777c4.1-1.9 7.9-3.8 11.8-5.7z" fill="#A4BEFF" p-id="3071"></path><path d="M812.4 534.8v86.7H215.3V300.7h234z" fill="#E5ECFF" p-id="3072"></path></svg>

    <span style="font-weight: bold;
									font-size: 20px;
									padding-top: 3px;
									padding-left: 5px;
									font-family: Chalkduster;
									color: #056de8;">
		
									xcoding.tech

		</span>

    <span class="title"></span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            <li class="pure-menu-item"><a href="/" class="pure-menu-link">首页</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/search" class="pure-menu-link">搜索</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/tags" class="pure-menu-link">标签</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/archives" class="pure-menu-link">归档</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/atom.xml" class="pure-menu-link">订阅</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/about" class="pure-menu-link">关于</a></li>
          
      
  </ul>
   
</nav>
  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        Spring后置处理器
      </h1>
      <span>
        
        <time class="time" datetime="2021-04-19T07:24:46.000Z">
        2021-04-19
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>
      </span>
    </span>
      
      <span class="slash">/</span>
      <span class="read">阅读耗时预计 22 分钟</span>
    </header>

    <div class="post-content">
      <p>本篇来总结汇总Spring各种类型后置处理器的使用。</p>
<h3 id="bean定义后置处理器"><a href="#bean定义后置处理器" class="headerlink" title="bean定义后置处理器"></a>bean定义后置处理器</h3><p>bean定义后置处理器是Spring框架提供的第一个扩展点。其中有两个接口，一个是<code>BeanFactoryPostProcessor</code>接口，一个是<code>BeanDefinitionRegistryPostProcessor</code>接口。</p>
<h4 id="BeanFactroyPostProcessor接口"><a href="#BeanFactroyPostProcessor接口" class="headerlink" title="BeanFactroyPostProcessor接口"></a>BeanFactroyPostProcessor接口</h4><p><code>BeanFactoryPostProcessor</code>接口提供的扩展功能：</p>
<blockquote>
<p><strong>允许用户修改容器中的bean定义信息，调整bean定义属性值。容器会在所有bean定义信加载完毕之后回调此接口，用以修改容器中的bean定义信息</strong>。但是不要在此接口直接通过<code>getBean</code>实例化bean，这样会导致bean过早实例化，违反容器规则导致不可预知的副作用。</p>
<p>如果要实现bean实例化请通过<code>BeanPostProcessor</code>接口实现。</p>
<p>如果有多个<code>BeanFactoryPostProcessor</code>接口并且需要执行它们的执行顺序可以同时实现<code>PriorityOrdered</code>接口或者<code>Ordered</code>接口。</p>
<p>简单讲就是，我们可以通过实现此接口获取到<code>BeanFactory</code>对象（就是参数），操作<code>BeanFactory</code>对象，修改里面的<code>BeanDefinition</code>。<br><strong>但是不要去实例化bean</strong>。</p>
<p>接口的一个典型应用就是<code>PropertySourcesPlaceholderConfigurer</code>。</p>
</blockquote>
<h5 id="接口源码"><a href="#接口源码" class="headerlink" title="接口源码"></a>接口源码</h5><p>Spring框架<code>BeanFactoryPostProcessor</code>接口源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 允许自定义修改容器中的bean定义信息，调整bean定义属性值。</span></span><br><span class="line"><span class="comment"> * 容器会在所有bean定义信息加载完毕之后回调此接口，用以修改容器中的bean定义信息。</span></span><br><span class="line"><span class="comment"> * 但是不要在此接口直接通过getBean实例化bean，这样会导致bean过早实例化，违反容器规则导致不可预知的副作用。</span></span><br><span class="line"><span class="comment"> * 如果要实现bean实例化请通过BeanPostProcessor接口。</span></span><br><span class="line"><span class="comment"> * 如果有多个BeanFactoryPostProcessor接口并且需要执行它们的执行顺序可以同时实现PriorityOrdered接口或者Ordered接口。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 简单讲就是，我们可以通过实现此接口获取到BeanFactory对象（就是参数），操作BeanFactory对象，修改里面的BeanDefinition。</span></span><br><span class="line"><span class="comment"> * 但是不要去实例化bean。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 另外有一点需要注意的是此接口的实现类会忽略懒加载设置，即使你显式设置了实现类懒加载也是不生效的。</span></span><br><span class="line"><span class="comment"> * 因为Spring需要保证BeanFactoryPostProcessor实现类优先实例化，如果实现类都懒加载了，那么你又如何能修改容器的bean定义呢。。。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Sam Brannen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 06.07.2003</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> PropertyResourceConfigurer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在所有的bean定义被加载到容器中后，并且是在所有bean实例化之前就会回调这个接口，</span></span><br><span class="line"><span class="comment">     * 这个接口可以修改容器中的所有bean定义信息，包括重写某些bean的定义属性信息。</span></span><br><span class="line"><span class="comment">     * 比如修改MyServiceImpl为懒加载：beanFactory.getMergedBeanDefinition(MyServiceImpl.class.getName()).setLazyInit(true);</span></span><br><span class="line"><span class="comment">     * 另外一个很典型的应用就是修改bean定义中属性的占位符（PropertySourcesPlaceholderConfigurer），比如读取配置文件把配置文件的配置值注入到类属性上</span></span><br><span class="line"><span class="comment">     * 最常见的就是<span class="doctag">@Value</span>(&quot;$&#123;xxxx&#125;&quot;)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注意：不要在此接口中实例化bean（就是不要调getBean()方法），提前实例化bean会导致不可预知的结果，</span></span><br><span class="line"><span class="comment">     * 因为目前还处在解析完所有bean定义阶段，bean的实例化（实例化就是根据bean的定义信息创建实例对象）还在后面的阶段。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h5><p>自定义一个实现类，验证。</p>
<ol>
<li>修改某个bean的定义信息</li>
<li>接口实现来显式设置为懒加载，看是否有效果（正常情况下应该是无效果的，Spring需要保证实现类提前初始化，否则谈何能修改bean定义）。容器启动的过程中就会打印构造方法的日志</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ubuntuvim.spring.beanfactorypostprocessor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Lazy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Spring的一个扩展点，实现BeanFactoryPostProcess接口。</span></span><br><span class="line"><span class="comment"> * 1. 修改某个bean的定义信息</span></span><br><span class="line"><span class="comment"> * 2. 接口实现来显式设置为懒加载，看是否有效果（正常情况下应该是无效果的，Spring需要保证实现类提前初始化，否则谈何能修改bean定义）</span></span><br><span class="line"><span class="comment"> *        容器启动的过程中就会打印构造方法的日志</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 运行结果：</span></span><br><span class="line"><span class="comment"> * com.ubuntuvim.spring.processor.MyBeanFactoryPostProcessorImpl被加载了。。。</span></span><br><span class="line"><span class="comment"> * com.ubuntuvim.spring.bean.LazyLoadingBean被设置成懒加载了。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 没有看到LazyLoadingBean被加载的日志，把beanFactory.getBeanDefinition(beanName).setLazyInit(true);改成false再运行：</span></span><br><span class="line"><span class="comment"> * com.ubuntuvim.spring.processor.MyBeanFactoryPostProcessorImpl被加载了。。。</span></span><br><span class="line"><span class="comment"> * com.ubuntuvim.spring.bean.LazyLoadingBean被设置成懒加载了。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * com.ubuntuvim.spring.bean.LazyLoadingBean被加载了。。。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 可以看到LazyLoadingBean被加载了，完美的验证了前面的两点描述</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: ubuntuvim</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/9/23 下午9:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Lazy</span>  <span class="comment">// 显式指定为懒加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessorImpl</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBeanFactoryPostProcessorImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + <span class="keyword">this</span>.getClass().getName() + <span class="string">&quot;被加载了。。。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// @Component注解没有指定名称，所有是默认首字母小写名字</span></span><br><span class="line">        String beanName = <span class="string">&quot;lazyLoadingBean&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + beanName + <span class="string">&quot;被设置成懒加载了。\n&quot;</span>);</span><br><span class="line">        beanFactory.getBeanDefinition(beanName).setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义一个普通bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ubuntuvim.spring.beanfactorypostprocessor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个bean在MyBeanFactoryPostProcessorImpl中被设置懒加载了，所以容器启动完毕也会不打印构造方法的日志</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: ubuntuvim</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/9/23 下午10:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyLoadingBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LazyLoadingBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + <span class="keyword">this</span>.getClass().getName() + <span class="string">&quot;被加载了。。。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.ubuntuvim.spring.beanfactorypostprocessor.MyBeanFactoryPostProcessorImpl被加载了。。。</span><br><span class="line"></span><br><span class="line">lazyLoadingBean被设置成懒加载了。</span><br></pre></td></tr></table></figure>

<p><code>MyBeanFactoryPostProcessorImpl</code>被加载了，<code>LazyLoadingBean</code>没有被加载，把<code>beanFactory.getBeanDefinition(beanName).setLazyInit(true);</code>改成<code>false</code>再运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">com.ubuntuvim.spring.beanfactorypostprocessor.MyBeanFactoryPostProcessorImpl被加载了。。。</span><br><span class="line"></span><br><span class="line">lazyLoadingBean被设置成懒加载了。</span><br><span class="line"></span><br><span class="line">com.ubuntuvim.spring.beanfactorypostprocessor.LazyLoadingBean被加载了。。。</span><br></pre></td></tr></table></figure>

<p>可以看到<code>MyBeanFactoryPostProcessorImpl</code>被加载了，<code>LazyLoadingBean</code>也被加载了，完美符合预期。</p>
<h4 id="待跟进"><a href="#待跟进" class="headerlink" title="待跟进"></a>待跟进</h4><p>学习<code>PropertyResourceConfigurer</code>是如何替换类中的占位符<code>@Value(&quot;$&#123;xxx&#125;&quot;)</code>。</p>
<h4 id="BeanDefinitionRegistryPostProcessor接口"><a href="#BeanDefinitionRegistryPostProcessor接口" class="headerlink" title="BeanDefinitionRegistryPostProcessor接口"></a>BeanDefinitionRegistryPostProcessor接口</h4><p><code>BeanDefinitionRegistryPostProcessor</code>接口的提供的扩展功能是：</p>
<blockquote>
<p><code>BeanDefinitionRegistryPostProcessor</code>接口是<code>BeanFactoryPostProcessor</code>接口的子类，它在父类的基础上增加了<code>postProcessBeanDefinitionRegistry()</code>方法。允许用户获取<code>BeanDefinitionRegistry</code>对象，从而可以<strong>通过编码方式动态修改、新增</strong><code>BeanDefinition</code>。</p>
<p>此接口一个非常重要的实现类就是<code>ConfigurationClassPostProcessor</code>，这个类用于解析<code>@Component</code>，<code>@Service</code>，<code>@ComponentScan</code>，<code>@Configuration</code>等注解，把注解对应的类转换成<code>BeanDefinition</code>然后注册到IoC容器中。</p>
</blockquote>
<h5 id="接口源码-1"><a href="#接口源码-1" class="headerlink" title="接口源码"></a>接口源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.support;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Extension to the standard &#123;<span class="doctag">@link</span> BeanFactoryPostProcessor&#125; SPI, allowing for</span></span><br><span class="line"><span class="comment"> * the registration of further bean definitions &lt;i&gt;before&lt;/i&gt; regular</span></span><br><span class="line"><span class="comment"> * BeanFactoryPostProcessor detection kicks in. In particular,</span></span><br><span class="line"><span class="comment"> * BeanDefinitionRegistryPostProcessor may register further bean definitions</span></span><br><span class="line"><span class="comment"> * which in turn define BeanFactoryPostProcessor instances.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 扩展标准的BeanFactoryPostProcessor SPI，</span></span><br><span class="line"><span class="comment"> * 允许在常规BeanFactoryPostProcessor检测开始之前注册其他的bean定义，特别是，</span></span><br><span class="line"><span class="comment"> * BeanDefinitionRegistryPostProcessor可以注册其他的bean定义，</span></span><br><span class="line"><span class="comment"> * 这些定义反过来可以用于定义BeanFactoryPostProcessor实例。</span></span><br><span class="line"><span class="comment"> * （也就是说可以借此方法往容器中注入bean定义）一个典型的使用就是ConfigurationClassPostProcessor，</span></span><br><span class="line"><span class="comment"> * 这个类用于解析<span class="doctag">@Component</span>，<span class="doctag">@Services</span>，<span class="doctag">@ComponentScan</span>，<span class="doctag">@Configuration</span>等注解，把注解对应的类转换成BeanDefinition然后注册到IoC容器中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.annotation.ConfigurationClassPostProcessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Modify the application context&#x27;s internal bean definition registry after its</span></span><br><span class="line"><span class="comment">     * standard initialization. All regular bean definitions will have been loaded,</span></span><br><span class="line"><span class="comment">     * but no beans will have been instantiated yet. This allows for adding further</span></span><br><span class="line"><span class="comment">     * bean definitions before the next post-processing phase kicks in.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 在标准bean初始化前修改、新增bean定义。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry the bean definition registry used by the application context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用案例-1"><a href="#使用案例-1" class="headerlink" title="使用案例"></a>使用案例</h5><p>自定义一个实现类，通过编码的方式往容器注入一个bean定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ubuntuvim.spring.beanfactorypostprocessor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.RootBeanDefinition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Lazy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过编程方式注册InjectBeanFromPostProcessor</span></span><br><span class="line"><span class="comment"> * 同样的本类设置成懒加载也是无效的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: ubuntuvim</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/7/17 20:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanDefinitionRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBeanDefinitionRegistryPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + <span class="keyword">this</span>.getClass().getName() + <span class="string">&quot;被加载了。。。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">//编程方式注入一个bean定义</span></span><br><span class="line">        registry.registerBeanDefinition(InjectBeanFromPostProcessor.class.getName(),</span><br><span class="line">                <span class="keyword">new</span> RootBeanDefinition(InjectBeanFromPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 本方法的功能和BeanFactoryPostProcessor一样。本来就是从BeanFactoryPostProcessor继承过来的。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>InjectBeanFromPostProcessor</code>并没有使用任何注解，也没有通过其他方式导入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ubuntuvim.spring.beanfactorypostprocessor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过BeanDefinitionRegistryPostProcessor接口注入本类到容器中。</span></span><br><span class="line"><span class="comment"> * 并没有在类上使用任何注解，也没有通过其他方式导入容器，期望效果是容器启动完毕之后会打印构造方法的日志</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: ubuntuvim</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/9/23 下午11:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectBeanFromPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InjectBeanFromPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + <span class="keyword">this</span>.getClass().getName() + <span class="string">&quot;被加载了。。。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">com.ubuntuvim.spring.beanfactorypostprocessor.MyBeanDefinitionRegistryPostProcessor被加载了。。。</span><br><span class="line"></span><br><span class="line">com.ubuntuvim.spring.beanfactorypostprocessor.InjectBeanFromPostProcessor被加载了。。。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果符合预期，<code>InjectBeanFromPostProcessor</code>成功注册到IoC容器中，并且可以被IoC容器实例化。</p>
<p>以上两个接口就是Spring框架提供的第一个扩展点，用于修改为实例化之前的bean定义信息。</p>
<h4 id="ConfigurationClassPostProcessor接口"><a href="#ConfigurationClassPostProcessor接口" class="headerlink" title="ConfigurationClassPostProcessor接口"></a>ConfigurationClassPostProcessor接口</h4><h5 id="接口源码-2"><a href="#接口源码-2" class="headerlink" title="接口源码"></a>接口源码</h5><h5 id="使用案例-2"><a href="#使用案例-2" class="headerlink" title="使用案例"></a>使用案例</h5><h4 id="ConfigurationClassPostProcessor接口-1"><a href="#ConfigurationClassPostProcessor接口-1" class="headerlink" title="ConfigurationClassPostProcessor接口"></a>ConfigurationClassPostProcessor接口</h4><h5 id="接口源码-3"><a href="#接口源码-3" class="headerlink" title="接口源码"></a>接口源码</h5><h5 id="使用案例-3"><a href="#使用案例-3" class="headerlink" title="使用案例"></a>使用案例</h5><h4 id="SmartInitializingSingleton接口"><a href="#SmartInitializingSingleton接口" class="headerlink" title="SmartInitializingSingleton接口"></a>SmartInitializingSingleton接口</h4><p><strong>这个接口Spring4.1之后才有</strong></p>
<blockquote>
<p><code>SmartInitializingSingleton</code>是spring 4.1中引入的新特效，与<code>InitializingBean</code>的功能类似，都是<strong>bean实例化后执行自定义初始化</strong>，都是属于<a target="_blank" rel="noopener" href="https://blog.csdn.net/alex_xfboy/article/details/51211054">spring bean生命周期</a>的增强。但是，<code>SmartInitializingSingleton</code>的<strong>定义及触发方式方式上有些区别</strong>，它的定义不在当前的bean中（a bean’s local construction phase），它是回调接口（针对<strong>非lazy单例Bean</strong>），回调的操作是由spring事件<code>ContextRefreshedEvent</code>触发。</p>
</blockquote>
<h5 id="接口源码-4"><a href="#接口源码-4" class="headerlink" title="接口源码"></a>接口源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现该接口后，当所有单例 bean 都初始化完成以后， 容器会回调该接口的方法 afterSingletonsInstantiated。</span></span><br><span class="line"><span class="comment"> * 主要应用场合就是在所有单例 bean 创建完成之后，可以在该回调中做一些事情。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@PostConstruct</span>是最先被执行的，然后是InitializingBean，最后是SmartInitializingSingleton</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 为什么是在当所有单例 bean 都初始化完成以后才执行这个接口的原因直接看源码就知道了：</span></span><br><span class="line"><span class="comment"> * AbstractApplicationContext.refresh() -&gt; finishBeanFactoryInitialization() -&gt; ConfigurableListableBeanFactory.preInstantiateSingletons()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 但是需要注意：不要再次接口中提前使用容器管理的bean对象，</span></span><br><span class="line"><span class="comment"> * 因为此时直接通过getBean()方法获取到的实例还没通过IoC容器的其他初始化后置处理的增强。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartInitializingSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有单例对象都是实例化完成之后就会回调这个接口实现类的此方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterSingletonsInstantiated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SmartInitializingSingleton</code>接口的实现主要是Spring框架内部使用，目前Spring框架内部已经有差不多30个实现类。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-677ccab99e962d5562335695f80b97a8340.png" alt="SmartInitializingSingleton接口实现类"></p>
<p>一个很典型的应用是<code>EventListenerMethodProcessor</code>类，这个类的作用的是用来对 <code>@EventListener</code> 提供支持.</p>
<p>主要是标注了<code>@EventListener</code> 的方法进行解析, 然后转换为一个 <code>ApplicationListener</code>。解析的方法就是实现了<code>SmartInitializingSingleton</code>接口的<code>afterSingletonsInstantiated()</code>方法，在这个方法中处理。</p>
<h5 id="使用案例-4"><a href="#使用案例-4" class="headerlink" title="使用案例"></a>使用案例</h5><p>定义一个实现类，同时实现了<code>SmartInitializingSingleton</code>接口和<code>InitializingBean</code>接口，并且在类中使用<code>@PostConstruct</code>注解。验证这几种方式的初始化执行顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ubuntuvim.spring.beanpostprocess;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.SmartInitializingSingleton;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在所有bean实例化之后（初始化前）回调这个接口afterSingletonsInstantiated</span></span><br><span class="line"><span class="comment"> * 初始化操作执行顺序：<span class="doctag">@PostConstruct</span>是最先被执行的，然后是InitializingBean，最后是SmartInitializingSingleton</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySmartInitializingSingletonImpl</span> <span class="keyword">implements</span> <span class="title">SmartInitializingSingleton</span>, <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokePostConstruct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1. @PostConstruct注释方法被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterSingletonsInstantiated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3. SmartInitializingSingleton接口的afterSingletonsInstantiated()方法被执行了&quot;</span>);</span><br><span class="line">        InitBean initBean = applicationContext.getBean(InitBean.class);</span><br><span class="line">        initBean.f();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2. InitializingBean接口的afterPropertiesSet()方法被执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. @PostConstruct注释方法被执行</span><br><span class="line">2. InitializingBean接口的afterPropertiesSet()方法被执行了</span><br><span class="line">3. SmartInitializingSingleton接口的afterSingletonsInstantiated()方法被执行了</span><br><span class="line">com.ubuntuvim.spring.beanpostprocess.InitBean的方法f()被调用</span><br></pre></td></tr></table></figure>



<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
<h4 id="InstantiationAwareBeanPostProcessor接口"><a href="#InstantiationAwareBeanPostProcessor接口" class="headerlink" title="InstantiationAwareBeanPostProcessor接口"></a>InstantiationAwareBeanPostProcessor接口</h4><p>此接口主要的作用于目标对象实例化过程需要处理的事情，包括实例化对象前后过程以及实例化属性的设置。<code>InstantiationAwareBeanPostProcessor</code>是Spring框架非常非常重要的接口，不亚于<code>BeanPostProcessor</code>接口。特别是Spring框架内部，非常多的扩展功能都是通过实现<code>InstantiationAwareBeanPostProcessor</code>接口完成的。比如：<code>AutowiredAnnotationBeanPostProcessor</code>就是实现这个接口的实现了<code>@Autowire</code>和<code>@Value</code>注解的处理，这个接口还有一个很重要的子接口<code>SmartInstantiationAwareBeanPostProcessor</code>。</p>
<p>对于Spring框架的用户，Spring推荐使用它的一个适配器类<code>InstantiationAweraBeanPostProcessorAdapter</code>。</p>
<h5 id="接口源码-5"><a href="#接口源码-5" class="headerlink" title="接口源码"></a>接口源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.PropertyValues;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.beans.PropertyDescriptor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 它在目标对象实例化之前调用，该方法的返回值类型是Object，我们可以返回任何类型的值。</span></span><br><span class="line"><span class="comment">     * 由于这个时候目标对象还未实例化，所以这个返回值可以用来代替原本该生成的目标对象的实例(比如代理对象)。</span></span><br><span class="line"><span class="comment">     * 如果该方法的返回值代替原本该生成的目标对象，后续只有postProcessAfterInitialization方法会调用，其它方法不再调用；否则按照正常的流程走</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在目标对象实例化之后调用，这个时候对象已经被实例化，但是该实例的属性还未被设置，都是null。</span></span><br><span class="line"><span class="comment">     * 因为它的返回值是决定要不要调用postProcessPropertyValues方法的其中一个因素（因为还有一个因素是mbd.getDependencyCheck()）；</span></span><br><span class="line"><span class="comment">     * 如果该方法返回false,并且不需要check，那么postProcessPropertyValues就会被忽略不执行；如果返回true，postProcessPropertyValues就会被执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 和postProcessPropertyValues方法同样的作用，Spring5.1之后新增的方法，用于替换postProcessPropertyValues。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 属性值进行修改；如果postProcessAfterInstantiation方法返回false，该方法不会被调用。</span></span><br><span class="line"><span class="comment">     * 声明为过程，Spring5.1之后推荐使用postProcessProperties()方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pvs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此接口的主要作用在<strong>目标对象的实例化过程中需要处理的事情</strong>，包括实例化对象的前后过程以及实例的属性设置。此接口是Spring框架内部使用的非常重要的接口，它是<code>BeanPostProcessor</code>的一个子接口，总共有6个方法。</p>
<ol>
<li><p><code>postProcessBeforeInitialization()</code>方法，继承至父类<code>BeanPostProcessor</code>接口中的方法,在Bean<strong>实例化完成且初始化方法执行之前</strong>执行</p>
</li>
<li><p><code>postProcessAfterInitialization()</code>方法，继承至父类<code>BeanPostProcessor</code>接口中的方法，在Bean<strong>实例化完成且初始化方法执行完成之后</strong>执行</p>
</li>
<li><p><code>postProcessBeforeInstantiation()</code>方法，自身方法，是最先执行的方法，它在目标对象<strong>实例化之前</strong>调用，该方法的返回值类型是<code>Object</code>，我们可以返回任何类型的值。<br>由于这个时候目标对象还未实例化，所以这个返回值可以用来代替原本该生成的目标对象的实例(比如代理对象)。<br>如果该方法的返回值代替原本该生成的目标对象，后续只有<code>postProcessAfterInitialization()</code>方法会调用，其它方法不再调用；否则按照正常的流程走</p>
</li>
<li><p><code>postProcessAfterInstantiation()</code>方法，在目标对象<strong>实例化之后</strong>调用，这个时候对象已经被实例化，但是该实例的属性还未被设置，都是null。<br>因为它的返回值是决定要不要调用<code>postProcessPropertyValues()</code>方法的其中一个因素（因为还有一个因素是<code>mbd.getDependencyCheck()</code>）；<br>如果该方法返回<code>false</code>,并且不需要check，那么<code>postProcessPropertyValues()</code>方法就会被忽略不执行；如果返回<code>true</code>，<code>postProcessPropertyValues()</code>方法就会被执行</p>
</li>
<li><p><code>postProcessPropertyValues()</code>方法（已经声明为过时，5.1版本之后推荐使用<code>postProcessPropertyValues()</code>方法），自身方法，对属性值进行修改；如果<code>postProcessAfterInstantiation()</code>方法返回false，该方法不会被调用。可以在该方法内对属性值进行修改</p>
</li>
<li><p><code>postProcessProperties()</code>方法，此方法和<code>postProcessPropertyValues()</code>方法是同样的作用。5.1版本之后推荐使用的方法。</p>
</li>
</ol>
<p>这个几个方法执行顺序如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-1b60268dfc0f4c62017d84ec5f611d3ab27.png" alt="InstantiationAwareBeanPostProcessor方法执行顺序"></p>
<h5 id="使用案例-5"><a href="#使用案例-5" class="headerlink" title="使用案例"></a>使用案例</h5><p>接下来，通过学习Spring框架内部使用的实现类来学习这个接口的使用场景。</p>
<h5 id="实现类之一AutowiredAnnotationBeanPostProcessor"><a href="#实现类之一AutowiredAnnotationBeanPostProcessor" class="headerlink" title="实现类之一AutowiredAnnotationBeanPostProcessor"></a>实现类之一AutowiredAnnotationBeanPostProcessor</h5><p>此后置处理器是一个集大成者，它做了非常非常多的事情。是Spring框架非常重要第一个后置处理器，首先看下类结构。</p>
<pre class="mermaid">graph BT

AutowiredAnnotationBeanPostProcessor -.-> MergedBeanDefinitionPostProcessor
MergedBeanDefinitionPostProcessor --> BeanPostProcessor

AutowiredAnnotationBeanPostProcessor -.-> PriorityOrdered
PriorityOrdered --> Ordered

AutowiredAnnotationBeanPostProcessor --> InstantiationAwareBeanPostProcessorAdapter
InstantiationAwareBeanPostProcessorAdapter -.-> SmartInstantiationAwareBeanPostProcessor
SmartInstantiationAwareBeanPostProcessor --> InstantiationAwareBeanPostProcessor
InstantiationAwareBeanPostProcessor --> BeanPostProcessor

AutowiredAnnotationBeanPostProcessor -.-> BeanFactoryAware
BeanFactoryAware --> Aware</pre>

<p>从类继承关系可以看到，它继承两个非常重要的后置处理器，第一个是<code>MergedBeanDefinitionBeanPostProcessor</code>，第二个是<code>InstantiationAwareBeanPostProcessor</code>。第一个在下一篇将会为你解析，第二个后置处理器在前面介绍过，<code>AutowiredAnnotationBeanPostProcessor</code>就是它的一个很重要的实现。</p>
<p>那么<code>AutowiredAnnotationBeanPostProcessor</code>重新实现这两个接口之后有做了什么呢？？</p>
<p>首先大概介绍它的功能：</p>
<ol>
<li>处理<code>@Value</code>注解</li>
<li><code>处理@Autowired</code>注解</li>
<li>处理<code>@Inject</code>注解</li>
<li>处理构造方法属性注入</li>
</ol>
<p><strong>注意</strong>：如果一个属性同时使用了<code>@Autowired</code>注解，也使用xml方式注入。那么注解注入的值会被xml注入的值覆盖，也就是说xml方式的注入是在注解注入之后执行。</p>
<p>另外<code>AutowiredAnnotationBeanPostProcessor</code>这个后置处理器在框架内部不是必须加载的，只有在项目中使用了<code>@ComponentScan</code>注解或者使用了<code>&lt;context:component-scan&gt;</code>标签或者使用<code>&lt;context:annotation-config&gt;</code>标签，Spring容器会自动加载此后置处理器。如果你自定义了或者重写了它，在项目加载时请把它排除，以免冲突。</p>
<p>摘其中2个很重要的方法讲下，一个是<code>postProcessMergedBeanDefinition()</code>方法，此方法用于查找出bean中使用了<code>@Autowired</code>注解的属性和使用此注解的方法，并且把属性名和方法名缓存起来；另一个方法是<code>postProcessProperties()</code>，这个方法用于属性值的注入，直接从缓存中获取到属性名或者方法名，然后通过反射注入值。</p>
<h4 id="postProcessMergedBeanDefinition方法"><a href="#postProcessMergedBeanDefinition方法" class="headerlink" title="postProcessMergedBeanDefinition方法"></a>postProcessMergedBeanDefinition方法</h4><p>查找出bean中使用了<code>@Autowired</code>注解的属性和使用此注解的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现接口MergedBeanDefinitionPostProcessor的方法：</span></span><br><span class="line"><span class="comment">     *  查询bean定义中是否有使用<span class="doctag">@Autowired</span>注解的属性并设置到缓存injectionMetadataCache中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanDefinition the merged bean definition for the bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanType the actual type of the managed bean instance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 查询bean实例的属性中使用@Autowired注解的属性或者方法并缓存好。</span></span><br><span class="line">  InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">// 检查属性是否已经被注入过，如果没有则把属性设置到缓存externallyManagedConfigMembers中。</span></span><br><span class="line">  metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">findAutowiringMetadata</span><span class="params">(String beanName, Class&lt;?&gt; clazz, <span class="meta">@Nullable</span> PropertyValues pvs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Fall back to class name as cache key, for backwards compatibility with custom callers.</span></span><br><span class="line">        String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());</span><br><span class="line">        <span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line">        InjectionMetadata metadata = <span class="keyword">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">        <span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.injectionMetadataCache) &#123;</span><br><span class="line">                metadata = <span class="keyword">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">                <span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (metadata != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        metadata.clear(pvs);</span><br><span class="line">                    &#125;</span><br><span class="line">                    metadata = buildAutowiringMetadata(clazz);</span><br><span class="line">                    <span class="keyword">this</span>.injectionMetadataCache.put(cacheKey, metadata);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> metadata;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是在创建bean的过程中回调方法。调用位置在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AbstractAutowireCapableBeanFactory#doCreateBean</span><br><span class="line">  &gt; AbstractAutowireCapableBeanFactory#applyMergedBeanDefinitionPostProcessors</span><br></pre></td></tr></table></figure>

<p>详细调用代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 执行后置处理器接口MergedBeanDefinitionPostProcessor，bean实例化之后，就可以通过反射获取到类或者属性上的注释信息</span></span><br><span class="line">      <span class="comment">// 处理@Resource、@Autowired、@Value注解的定义信息，并把这些注解的定义信息放在缓存中。待后续属性填充的时候使用。</span></span><br><span class="line">      <span class="comment">// 如果有则吧注解信息转换成AutowiredFieldElement对象或者AutowiredMethodElement对象或者ResourceElement对象</span></span><br><span class="line">      <span class="comment">// 实现类有：AutowiredAnnotationBeanPostProcessor、CommonAnnotationBeanPostProcessor等</span></span><br><span class="line">      applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                      <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用的时机是：bean实例化之后，属性填充之前（当然也是在初始化之前，属性填充完成才到初始化回调）。</p>
<p>通过方法<code>findAutowiringMetadata()</code>把使用<code>@Autowired</code>属性或者方法都找到并缓存到<code>injectionMetadataCache</code>里面，然后在填充属性的时候使用。</p>
<h4 id="postProcessProperties方法"><a href="#postProcessProperties方法" class="headerlink" title="postProcessProperties方法"></a>postProcessProperties方法</h4><p>此方法用于注入属性值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 扫描查找到bean实例里面使用@Autowired的属性或者方法，</span></span><br><span class="line">  <span class="comment">// 但是在postProcessMergedBeanDefinition()方法中已经完成了属性或者方法是查找，并且缓存起来了</span></span><br><span class="line">  <span class="comment">// 所以再调此方法时直接从缓存里面获取。</span></span><br><span class="line">  InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 通过反射完成属性注入：field.set(target, value)</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@see</span> org.springframework.beans.factory.annotation.InjectionMetadata#inject</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">    metadata.inject(bean, beanName, pvs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;Injection of autowired dependencies failed&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>postProcessProperties()</code>方法的调用时机是在<code>postProcessMergedBeanDefinition()</code>方法之后，调用外置也是在创建bean的时候。调用位置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AbstractAutowireCapableBeanFactory#doCreateBean</span><br><span class="line">    &gt;AbstractAutowireCapableBeanFactory#populateBean </span><br></pre></td></tr></table></figure>

<p>调用时机：bean实例化完成之后，初始化之前，而且是在<code>postProcessAfterInstantiation()</code>方法之后。如果不记得请回到文章开头的调用顺序图。Spring框架内部的后置处理器回调时机是非常重要的。</p>
<p>调用代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ………… 篇幅有限省略其他代码</span></span><br><span class="line">  PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">    <span class="comment">// 依赖注入模式不是byType或者byName的情况有可能为空，这两种情况执行了pvs = newPvs不会为null</span></span><br><span class="line">    <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">      pvs = mbd.getPropertyValues();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 属性注入，包括依赖对象注入，依赖集合注入，</span></span><br><span class="line"><span class="comment">                     * 比如下面这3种写法，都会在此完成属性注入</span></span><br><span class="line"><span class="comment">                     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@Autowired</span></span></span><br><span class="line"><span class="comment">                     * private Fruit apple;</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@Autowired</span></span></span><br><span class="line"><span class="comment">                     * private List&lt;InterfaceA&gt; interfaceAList;</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * 同理，Map也是一样的</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@Autowired</span></span></span><br><span class="line"><span class="comment">                     * private Map&lt;String, InterfaceA&gt; interfaceAMap;</span></span><br><span class="line"><span class="comment">                     * key就是实现类的beanName，value就是实现类实例对象。</span></span><br><span class="line"><span class="comment">                     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">                     * 其中AutowiredAnnotationBeanPostProcessor这个后置处理器用于给<span class="doctag">@Autowired</span>注解或者<span class="doctag">@Value</span>注解定义的属性注入值，</span></span><br><span class="line"><span class="comment">                     * 注入的步骤：1. 扫描bean实例中使用<span class="doctag">@Autowired</span>注解的属性和方法，2. 根据注入的类型从IoC容器中在匹配的bean；3. 通过反射执行赋值操作</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@see</span> org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#postProcessProperties</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@see</span> org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#postProcessPropertyValues</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * 其中CommonAnnotationBeanPostProcessor这个后置处理器用于给<span class="doctag">@Resource</span>注解定义的属性注入值</span></span><br><span class="line"><span class="comment">                     * 同时这个类还处理了<span class="doctag">@PostConstruct</span>/<span class="doctag">@PreDestroy</span>这两个注解</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@see</span> org.springframework.context.annotation.CommonAnnotationBeanPostProcessor#postProcessProperties</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">        InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">        <span class="comment">// postProcessProperties()方法已经声明为过时。推荐使用postProcessPropertyValues()方法</span></span><br><span class="line">        PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">            filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">          &#125;</span><br><span class="line">          pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">          <span class="comment">// 如果返回的属性值为null直接退出当前方法，说明没有可填充的属性</span></span><br><span class="line">          <span class="comment">// 在实现后置处理器的时候特别要注意接口方法的返回值已经执行顺序，如果第一个后置处理器就返回了null，</span></span><br><span class="line">          <span class="comment">// 那么同一类型的其他排在后面的就不会执行了</span></span><br><span class="line">          <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pvs = pvsToUse;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ………… 篇幅有限省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码的逻辑是比较简单的，获取到后置处理器后执行对应的回调完成的。详细的解释也可以看源码的注释。</p>
<p>到此通过Spring框架内部的<code>AutowiredAnnotationBeanPostProcessor</code>类学习了<code>InstantiationAwareBeanPostProcessor</code>这个后置处理器的使用。</p>
<p>如果你在开发过程中也需要用到一些自定义的注解，而又不知道该在什么时候让自定义的注解生效。那么你可以参考<code>AutowiredAnnotationBeanPostProcessor</code>的实现，来完成自定义注解的解析、应用。</p>
<p>=======</p>
<h4 id="InstantiationAwareBeanPostProcessor接口或者InstantiationAwareBeanPostProcessorAdapter"><a href="#InstantiationAwareBeanPostProcessor接口或者InstantiationAwareBeanPostProcessorAdapter" class="headerlink" title="InstantiationAwareBeanPostProcessor接口或者InstantiationAwareBeanPostProcessorAdapter"></a>InstantiationAwareBeanPostProcessor接口或者InstantiationAwareBeanPostProcessorAdapter</h4><h5 id="接口源码-6"><a href="#接口源码-6" class="headerlink" title="接口源码"></a>接口源码</h5><h5 id="使用案例-6"><a href="#使用案例-6" class="headerlink" title="使用案例"></a>使用案例</h5><blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>8acc8492f5f2286c54fa6be583a14cccfeed7585</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h4 id="MergedBeanDefinitionPostProcessor接口"><a href="#MergedBeanDefinitionPostProcessor接口" class="headerlink" title="MergedBeanDefinitionPostProcessor接口"></a>MergedBeanDefinitionPostProcessor接口</h4><h5 id="接口源码-7"><a href="#接口源码-7" class="headerlink" title="接口源码"></a>接口源码</h5><h5 id="使用案例-7"><a href="#使用案例-7" class="headerlink" title="使用案例"></a>使用案例</h5><h4 id="SmartInstantiationAwareBeanPostProcessor接口"><a href="#SmartInstantiationAwareBeanPostProcessor接口" class="headerlink" title="SmartInstantiationAwareBeanPostProcessor接口"></a>SmartInstantiationAwareBeanPostProcessor接口</h4><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>同<code>InstantiationAwareBeanPostProcessorAdapter</code><br>=======</p>
<h5 id="接口源码-8"><a href="#接口源码-8" class="headerlink" title="接口源码"></a>接口源码</h5><h5 id="使用案例-8"><a href="#使用案例-8" class="headerlink" title="使用案例"></a>使用案例</h5><blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>8acc8492f5f2286c54fa6be583a14cccfeed7585</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h4 id="BeanFactoryAware-ApplicationContextAware-BeanNameAware接口"><a href="#BeanFactoryAware-ApplicationContextAware-BeanNameAware接口" class="headerlink" title="BeanFactoryAware/ApplicationContextAware/BeanNameAware接口"></a>BeanFactoryAware/ApplicationContextAware/BeanNameAware接口</h4><h5 id="接口源码-9"><a href="#接口源码-9" class="headerlink" title="接口源码"></a>接口源码</h5><h5 id="使用案例-9"><a href="#使用案例-9" class="headerlink" title="使用案例"></a>使用案例</h5><h4 id="CommonAnnotationBeanPostProcessor"><a href="#CommonAnnotationBeanPostProcessor" class="headerlink" title="CommonAnnotationBeanPostProcessor"></a>CommonAnnotationBeanPostProcessor</h4><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>同<code>InitDestoryAnnotationBeanPostProcessor</code></p>
<h4 id="AutowiredAnnotationBeanPostProcessor"><a href="#AutowiredAnnotationBeanPostProcessor" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h4><p>同前面的<code>InstantiationAwareBeanPostProcessor</code></p>
<h4 id="InitDestroyAnnotationBeanPostProcessor类"><a href="#InitDestroyAnnotationBeanPostProcessor类" class="headerlink" title="InitDestroyAnnotationBeanPostProcessor类"></a>InitDestroyAnnotationBeanPostProcessor类</h4><p>单从类名字看就大概能猜到它的作用。此类就是用于处理初始化注解<code>@PostConstruct</code>和销毁注解<code>PreDestroy</code>。这两个注解在平常的Spring项目中也是非常采用的注解，特别是前者，通常用于自定义初始化逻辑。</p>
<p>首先看下类结构，看下它实现哪些后置处理器接口。</p>
<pre class="mermaid">graph BT

InitDestroyAnnotationBeanPostProcessor -.-> DestructionAwareBeanPostProcessor
DestructionAwareBeanPostProcessor --> BeanPostProcessor

InitDestroyAnnotationBeanPostProcessor -.-> MergedBeanDefinitionPostProcessor
MergedBeanDefinitionPostProcessor --> BeanPostProcessor

InitDestroyAnnotationBeanPostProcessor -.-> PriorityOrdered
PriorityOrdered --> Ordered</pre>

<p>从类层级结构更加清晰的看到这个后置处理的功能。 它首先是一个后置处理器，也是可设置顺序的；并且它还实现bean定义接口，也就是说这个类也是可以修改bean定义信息的。</p>
<p>其中核心的方法源码如下：</p>
<h5 id="接口源码-10"><a href="#接口源码-10" class="headerlink" title="接口源码"></a>接口源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitDestroyAnnotationBeanPostProcessor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">DestructionAwareBeanPostProcessor</span>, <span class="title">MergedBeanDefinitionPostProcessor</span>, <span class="title">PriorityOrdered</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现 MergedBeanDefinitionBeanPostProcessor接口的方法。</span></span><br><span class="line"><span class="comment">     * 方法调用入口：</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AbstractAutowireCapableBeanFactory#applyMergedBeanDefinitionPostProcessors(RootBeanDefinition, Class, String) </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanDefinition the merged bean definition for the bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanType the actual type of the managed bean instance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查找bean定义中是否有使用@PostConstruct注解或者@PreDestory注解的方法，如果有则缓存到lifecycleMetadataCache</span></span><br><span class="line">        <span class="comment">// 然后在postProcessBeforeInitialization()方法中使用缓存起来的信息</span></span><br><span class="line">        LifecycleMetadata metadata = findLifecycleMetadata(beanType);</span><br><span class="line">        metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现BeanPostProcessor接口的方法。</span></span><br><span class="line"><span class="comment">     * 执行<span class="doctag">@PostConstruct</span>注解声明的方法，用于自定义初始化内容。</span></span><br><span class="line"><span class="comment">     * 调用入口：</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization(Object, String)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean the new bean instance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 前面的postProcessMergedBeanDefinition()方法已经把@PostConstruct注解或者@PreDestory注解定义的方法缓存了。</span></span><br><span class="line">        <span class="comment">// 这里就直接从缓存里面获取</span></span><br><span class="line">        LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            metadata.invokeInitMethods(bean, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex.getTargetException());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;Failed to invoke init method&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeforeDestruction</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行@PreDestroy注解的销毁回调方法，如果一个类中多个方法都是用了这个注解，会遍历执行所有的注解方法</span></span><br><span class="line">            metadata.invokeDestroyMethods(bean, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            String msg = <span class="string">&quot;Destroy method on bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; threw an exception&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.warn(msg, ex.getTargetException());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.warn(msg + <span class="string">&quot;: &quot;</span> + ex.getTargetException());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Failed to invoke destroy method on bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> LifecycleMetadata <span class="title">findLifecycleMetadata</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.lifecycleMetadataCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Happens after deserialization, during destruction...</span></span><br><span class="line">            <span class="keyword">return</span> buildLifecycleMetadata(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line">        LifecycleMetadata metadata = <span class="keyword">this</span>.lifecycleMetadataCache.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (metadata == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.lifecycleMetadataCache) &#123;</span><br><span class="line">                metadata = <span class="keyword">this</span>.lifecycleMetadataCache.get(clazz);</span><br><span class="line">                <span class="keyword">if</span> (metadata == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 通过反射获取到使用@PostConstruct注解或者@PreDestory注解的方法，并包装成LifecycleMetadata</span></span><br><span class="line">                    metadata = buildLifecycleMetadata(clazz);</span><br><span class="line">                    <span class="keyword">this</span>.lifecycleMetadataCache.put(clazz, metadata);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> metadata;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> metadata;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找出目标类中的初始化方法（使用<span class="doctag">@PostConstruct</span>注解的方法）和销毁方法（使用<span class="doctag">@PreDestory</span>注解的方法）</span></span><br><span class="line"><span class="comment">     * 最后封到LifecycleMetadata对象里面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 目标类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> LifecycleMetadata <span class="title">buildLifecycleMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!AnnotationUtils.isCandidateClass(clazz, Arrays.asList(<span class="keyword">this</span>.initAnnotationType, <span class="keyword">this</span>.destroyAnnotationType))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.emptyLifecycleMetadata;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;LifecycleElement&gt; initMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;LifecycleElement&gt; destroyMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Class&lt;?&gt; targetClass = clazz;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> List&lt;LifecycleElement&gt; currInitMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">final</span> List&lt;LifecycleElement&gt; currDestroyMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过反射获取到目标类的方法列表，然后遍历这些方法判断是否有使用@PostConstruct注解以及@PreDestroy注解</span></span><br><span class="line">            <span class="comment">// 如果有则保存到currInitMethods</span></span><br><span class="line">            ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;</span><br><span class="line">                <span class="comment">// 查找使用@PostConstruct注解的方法</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.initAnnotationType != <span class="keyword">null</span> &amp;&amp; method.isAnnotationPresent(<span class="keyword">this</span>.initAnnotationType)) &#123;</span><br><span class="line">                    LifecycleElement element = <span class="keyword">new</span> LifecycleElement(method);</span><br><span class="line">                    currInitMethods.add(element);</span><br><span class="line">                    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                        logger.trace(<span class="string">&quot;Found init method on class [&quot;</span> + clazz.getName() + <span class="string">&quot;]: &quot;</span> + method);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 查找使用@PreDestroy注解的方法</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.destroyAnnotationType != <span class="keyword">null</span> &amp;&amp; method.isAnnotationPresent(<span class="keyword">this</span>.destroyAnnotationType)) &#123;</span><br><span class="line">                    currDestroyMethods.add(<span class="keyword">new</span> LifecycleElement(method));</span><br><span class="line">                    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                        logger.trace(<span class="string">&quot;Found destroy method on class [&quot;</span> + clazz.getName() + <span class="string">&quot;]: &quot;</span> + method);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            initMethods.addAll(<span class="number">0</span>, currInitMethods);</span><br><span class="line">            destroyMethods.addAll(currDestroyMethods);</span><br><span class="line">            targetClass = targetClass.getSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (targetClass != <span class="keyword">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (initMethods.isEmpty() &amp;&amp; destroyMethods.isEmpty() ? <span class="keyword">this</span>.emptyLifecycleMetadata :</span><br><span class="line">                <span class="keyword">new</span> LifecycleMetadata(clazz, initMethods, destroyMethods));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面逐个介绍这几个核心方法的使用。</p>
<h4 id="postProcessMergedBeanDefinition方法-1"><a href="#postProcessMergedBeanDefinition方法-1" class="headerlink" title="postProcessMergedBeanDefinition方法"></a>postProcessMergedBeanDefinition方法</h4><p>此方法是实现<code>MergedBeanDefinitionBeanPostProcessor</code>接口的方法。</p>
<p>方法执行入口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AbstractAutowireCapableBeanFactory#doCreateBean()</span><br><span class="line">  &gt; AbstractAutowireCapableBeanFactory#applyMergedBeanDefinitionPostProcessors()</span><br></pre></td></tr></table></figure>

<p>方法执行时机：</p>
<p>bean实例化之后，初始化之前。bean实例化之后就可以通过反射获取到类信息，然后遍历类里面的方法，逐个校验方法是否有使用<code>@PostConstruct</code>或者<code>@PreDestroy</code>注解。</p>
<p>实现逻辑是通过<code>findLifecycleMetadata(beanType)</code>方法实现。这个方法的代码和之前两篇初始化后置处理、实例化后置处理器的逻辑非常相似。查找到符合的方法之后封装成<code>LifecycleMetadata</code>对象，然后在缓存到<code>lifecycleMetadataCache</code>这个<code>ConcurrentHashMap</code>中。</p>
<h4 id="postProcessBeforeInitialization方法"><a href="#postProcessBeforeInitialization方法" class="headerlink" title="postProcessBeforeInitialization方法"></a>postProcessBeforeInitialization方法</h4><p>此方法是实现于<code>BeanPostProcessor</code>接口的。</p>
<p>此方法用于执行使用<code>@PostConstruct</code>的方法。底层也是通过反射执行。</p>
<p>方法执行入口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AbstractAutowireCapableBeanFactory#doCreateBean()</span><br><span class="line">  &gt; AbstractAutowireCapableBeanFactory#initializeBean()</span><br><span class="line">    &gt; AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization()</span><br></pre></td></tr></table></figure>

<p>方法执行时机：bean实例化后，且bean定义修改之后（postProcessMergedBeanDefinition()方法之后），且在属性填充之后。在bean初始化逻辑里面执行的。</p>
<p>执行的时机可以从Spring的源码摘出来，有兴趣的可以自行阅读<code>AbstractAutowireCapableBeanFactory</code>的<code>doCreateBean()</code>方法逻辑，这个方法可以说是Spring框架实现bean生命周期的最最最核心的方法。</p>
<p>这个方法逻辑也不复杂，就是从缓存里面获取使用<code>@PostConstruct</code>的方法，然后通过反射执行方法。核心的执行逻辑也就是如下两行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReflectionUtils.makeAccessible(<span class="keyword">this</span>.method);</span><br><span class="line"><span class="keyword">this</span>.method.invoke(target, (Object[]) <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p><code>this.method</code>就是被执行的方法，<code>target</code>就是目标bean，执行方法时参数是<code>null</code>。从这里<code>(Object[]) null</code>也可以看到，<code>@PostConstruct</code>注解定义的方法都是不接受参数的。</p>
<h4 id="postProcessBeforeDestruction方法"><a href="#postProcessBeforeDestruction方法" class="headerlink" title="postProcessBeforeDestruction方法"></a>postProcessBeforeDestruction方法</h4><p>此方法实现于<code>DestructionAwareBeanPostProcessor</code>接口。<br>作用是用于执行使用<code>@PreDestroy</code>注解的方法。它的底层也是通过反射执行，和<code>@PostConstruct</code>注解的执行原理是一样的。<br>但是这个方法的执行比较特殊，它的执行是依赖于容器的关闭事件的。也就是必须手动调用<code>AbstractApplicationContext.close()</code>方法才会触发调用。<br>很容易理解，销毁的方法不可能也是在<code>doCreateBean()</code>方法中执行，这个方法是用于创建、初始化bean。不能初始化完就销毁了，销毁了那么还用什么呢？</p>
<p>方法执行入口举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main方法</span><br><span class="line">  &gt; new AnnotationConfigApplicationContext(Config.class).close();</span><br><span class="line">    &gt; AbstractApplicationContext#close()</span><br><span class="line">      &gt; AbstractApplicationContext#doClose()</span><br><span class="line">        &gt; AbstractApplicationContext#destroyBeans()</span><br><span class="line">          &gt; DefaultListableBeanFactory#destroySingletons()</span><br><span class="line">            &gt; DefaultSingletonBeanRegistry#destroySingletons()</span><br><span class="line">              &gt; DefaultSingletonBeanRegistry#destroyBean()的bean.destroy()这行代码</span><br><span class="line">                &gt; DisposableBeanAdapter#destroy()  </span><br></pre></td></tr></table></figure>
<p>整个调用层次比较深，你可以打个断点到最后一个方法，然后在<code>main()</code>方法中debug模式运行。<br>最后的<code>DisposableBeanAdapter.destroy()</code>方法是所有销毁回调的执行入口，包括自定义的销毁方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!CollectionUtils.isEmpty(<span class="keyword">this</span>.beanPostProcessors)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (DestructionAwareBeanPostProcessor processor : <span class="keyword">this</span>.beanPostProcessors) &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 执行后置处理器的销毁回调方法</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@PreDestroy</span>注释的方法就是在这里执行的。默认实现有</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@see</span> InitDestroyAnnotationBeanPostProcessor#postProcessBeforeDestruction(Object, String)</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">      processor.postProcessBeforeDestruction(<span class="keyword">this</span>.bean, <span class="keyword">this</span>.beanName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.invokeDisposableBean) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Invoking destroy() on bean with name &#x27;&quot;</span> + <span class="keyword">this</span>.beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行DisposableBean接口的destory()方法。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">          ((DisposableBean) <span class="keyword">this</span>.bean).destroy();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, <span class="keyword">this</span>.acc);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        ((DisposableBean) <span class="keyword">this</span>.bean).destroy();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      String msg = <span class="string">&quot;Invocation of destroy method failed on bean with name &#x27;&quot;</span> + <span class="keyword">this</span>.beanName + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.warn(msg, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.warn(msg + <span class="string">&quot;: &quot;</span> + ex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 1. 执行自定义的销毁方法，比如下面自定义的销毁方法就是beanDestoryCallbackMethod()</span></span><br><span class="line">  <span class="comment">//         @Bean(destroyMethod = &quot;beanDestoryCallbackMethod&quot;)</span></span><br><span class="line">  <span class="comment">// 2. 执行实现Closable接口的close()方法。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">    invokeCustomDestroyMethod(<span class="keyword">this</span>.destroyMethod);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethodName != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Method methodToInvoke = determineDestroyMethod(<span class="keyword">this</span>.destroyMethodName);</span><br><span class="line">    <span class="keyword">if</span> (methodToInvoke != <span class="keyword">null</span>) &#123;</span><br><span class="line">      invokeCustomDestroyMethod(ClassUtils.getInterfaceMethodIfPossible(methodToInvoke));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此，<code>InitDestroyAnnotationBeanPostProcessor</code>初始、销毁后置处理器也介绍完了，不知道你看明白了吗？如果有疑问可以给我留言，我把演示的案例代码发给你。篇幅有限就在文章中直接贴代码了。</p>
<h1 id="总结下来，最最最重要的一点就是要搞懂doCreateBean-方法，这个方法是Spring-bean生命周期的实现。里面的后置处理器执行顺序决定了bean的实例化、bean定义合并、bean属性填充，bean初始化顺序。并且每个步骤都是通过执行对应的后置处理器来完成的。"><a href="#总结下来，最最最重要的一点就是要搞懂doCreateBean-方法，这个方法是Spring-bean生命周期的实现。里面的后置处理器执行顺序决定了bean的实例化、bean定义合并、bean属性填充，bean初始化顺序。并且每个步骤都是通过执行对应的后置处理器来完成的。" class="headerlink" title="总结下来，最最最重要的一点就是要搞懂doCreateBean()方法，这个方法是Spring bean生命周期的实现。里面的后置处理器执行顺序决定了bean的实例化、bean定义合并、bean属性填充，bean初始化顺序。并且每个步骤都是通过执行对应的后置处理器来完成的。"></a>总结下来，最最最重要的一点就是要搞懂<code>doCreateBean()</code>方法，这个方法是Spring bean生命周期的实现。里面的后置处理器执行顺序决定了bean的实例化、bean定义合并、bean属性填充，bean初始化顺序。并且每个步骤都是通过执行对应的后置处理器来完成的。</h1><h5 id="接口源码-11"><a href="#接口源码-11" class="headerlink" title="接口源码"></a>接口源码</h5><h5 id="使用案例-10"><a href="#使用案例-10" class="headerlink" title="使用案例"></a>使用案例</h5><h4 id="AutowiredAnnotationBeanPostProcessor-1"><a href="#AutowiredAnnotationBeanPostProcessor-1" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h4><h5 id="接口源码-12"><a href="#接口源码-12" class="headerlink" title="接口源码"></a>接口源码</h5><h5 id="使用案例-11"><a href="#使用案例-11" class="headerlink" title="使用案例"></a>使用案例</h5><h4 id="InitDestroyAnnotationBeanPostProcessor接口"><a href="#InitDestroyAnnotationBeanPostProcessor接口" class="headerlink" title="InitDestroyAnnotationBeanPostProcessor接口"></a>InitDestroyAnnotationBeanPostProcessor接口</h4><h5 id="接口源码-13"><a href="#接口源码-13" class="headerlink" title="接口源码"></a>接口源码</h5><h5 id="使用案例-12"><a href="#使用案例-12" class="headerlink" title="使用案例"></a>使用案例</h5><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a target="_blank" rel="noopener" href="https://fangjian0423.github.io/2017/06/20/spring-bean-post-processor/">https://fangjian0423.github.io/2017/06/20/spring-bean-post-processor/</a></p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>8acc8492f5f2286c54fa6be583a14cccfeed7585</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>

    </div>

      
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/Java/%E6%89%8B%E5%8A%A8%E5%8A%A0%E8%BD%BDjar%E5%B9%B6%E5%AE%9E%E4%BE%8B%E5%8C%96class/" rel="next" title="手动加载jar并实例化class">
          手动加载jar并实例化class
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/Spring/Spring%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9B%9E%E8%B0%83%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%90%9E%E6%87%82%E4%BA%86%E5%90%97%EF%BC%9F/" rel="prev" title="">
            
          </a>
          <span>〉</span>
        
      </div>
    </div>
  
  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#bean%E5%AE%9A%E4%B9%89%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">bean定义后置处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BeanFactroyPostProcessor%E6%8E%A5%E5%8F%A3"><span class="toc-text">BeanFactroyPostProcessor接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81"><span class="toc-text">接口源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-text">使用案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%85%E8%B7%9F%E8%BF%9B"><span class="toc-text">待跟进</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BeanDefinitionRegistryPostProcessor%E6%8E%A5%E5%8F%A3"><span class="toc-text">BeanDefinitionRegistryPostProcessor接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81-1"><span class="toc-text">接口源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-1"><span class="toc-text">使用案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConfigurationClassPostProcessor%E6%8E%A5%E5%8F%A3"><span class="toc-text">ConfigurationClassPostProcessor接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81-2"><span class="toc-text">接口源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-2"><span class="toc-text">使用案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConfigurationClassPostProcessor%E6%8E%A5%E5%8F%A3-1"><span class="toc-text">ConfigurationClassPostProcessor接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81-3"><span class="toc-text">接口源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-3"><span class="toc-text">使用案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SmartInitializingSingleton%E6%8E%A5%E5%8F%A3"><span class="toc-text">SmartInitializingSingleton接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81-4"><span class="toc-text">接口源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-4"><span class="toc-text">使用案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InstantiationAwareBeanPostProcessor%E6%8E%A5%E5%8F%A3"><span class="toc-text">InstantiationAwareBeanPostProcessor接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81-5"><span class="toc-text">接口源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-5"><span class="toc-text">使用案例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B9%8B%E4%B8%80AutowiredAnnotationBeanPostProcessor"><span class="toc-text">实现类之一AutowiredAnnotationBeanPostProcessor</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#postProcessMergedBeanDefinition%E6%96%B9%E6%B3%95"><span class="toc-text">postProcessMergedBeanDefinition方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#postProcessProperties%E6%96%B9%E6%B3%95"><span class="toc-text">postProcessProperties方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InstantiationAwareBeanPostProcessor%E6%8E%A5%E5%8F%A3%E6%88%96%E8%80%85InstantiationAwareBeanPostProcessorAdapter"><span class="toc-text">InstantiationAwareBeanPostProcessor接口或者InstantiationAwareBeanPostProcessorAdapter</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81-6"><span class="toc-text">接口源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-6"><span class="toc-text">使用案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MergedBeanDefinitionPostProcessor%E6%8E%A5%E5%8F%A3"><span class="toc-text">MergedBeanDefinitionPostProcessor接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81-7"><span class="toc-text">接口源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-7"><span class="toc-text">使用案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SmartInstantiationAwareBeanPostProcessor%E6%8E%A5%E5%8F%A3"><span class="toc-text">SmartInstantiationAwareBeanPostProcessor接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81-8"><span class="toc-text">接口源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-8"><span class="toc-text">使用案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BeanFactoryAware-ApplicationContextAware-BeanNameAware%E6%8E%A5%E5%8F%A3"><span class="toc-text">BeanFactoryAware&#x2F;ApplicationContextAware&#x2F;BeanNameAware接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81-9"><span class="toc-text">接口源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-9"><span class="toc-text">使用案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CommonAnnotationBeanPostProcessor"><span class="toc-text">CommonAnnotationBeanPostProcessor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AutowiredAnnotationBeanPostProcessor"><span class="toc-text">AutowiredAnnotationBeanPostProcessor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InitDestroyAnnotationBeanPostProcessor%E7%B1%BB"><span class="toc-text">InitDestroyAnnotationBeanPostProcessor类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81-10"><span class="toc-text">接口源码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#postProcessMergedBeanDefinition%E6%96%B9%E6%B3%95-1"><span class="toc-text">postProcessMergedBeanDefinition方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#postProcessBeforeInitialization%E6%96%B9%E6%B3%95"><span class="toc-text">postProcessBeforeInitialization方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#postProcessBeforeDestruction%E6%96%B9%E6%B3%95"><span class="toc-text">postProcessBeforeDestruction方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8B%E6%9D%A5%EF%BC%8C%E6%9C%80%E6%9C%80%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%B1%E6%98%AF%E8%A6%81%E6%90%9E%E6%87%82doCreateBean-%E6%96%B9%E6%B3%95%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E6%98%AFSpring-bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%AE%9E%E7%8E%B0%E3%80%82%E9%87%8C%E9%9D%A2%E7%9A%84%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%86%B3%E5%AE%9A%E4%BA%86bean%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81bean%E5%AE%9A%E4%B9%89%E5%90%88%E5%B9%B6%E3%80%81bean%E5%B1%9E%E6%80%A7%E5%A1%AB%E5%85%85%EF%BC%8Cbean%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E3%80%82%E5%B9%B6%E4%B8%94%E6%AF%8F%E4%B8%AA%E6%AD%A5%E9%AA%A4%E9%83%BD%E6%98%AF%E9%80%9A%E8%BF%87%E6%89%A7%E8%A1%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8%E6%9D%A5%E5%AE%8C%E6%88%90%E7%9A%84%E3%80%82"><span class="toc-text">总结下来，最最最重要的一点就是要搞懂doCreateBean()方法，这个方法是Spring bean生命周期的实现。里面的后置处理器执行顺序决定了bean的实例化、bean定义合并、bean属性填充，bean初始化顺序。并且每个步骤都是通过执行对应的后置处理器来完成的。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81-11"><span class="toc-text">接口源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-10"><span class="toc-text">使用案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AutowiredAnnotationBeanPostProcessor-1"><span class="toc-text">AutowiredAnnotationBeanPostProcessor</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81-12"><span class="toc-text">接口源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-11"><span class="toc-text">使用案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InitDestroyAnnotationBeanPostProcessor%E6%8E%A5%E5%8F%A3"><span class="toc-text">InitDestroyAnnotationBeanPostProcessor接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81-13"><span class="toc-text">接口源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-12"><span class="toc-text">使用案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">参考资料</span></a></li></ol></li></ol>
  </div>


  </div>
</div>


<div class="copyright">
    <span>本作品采用</span>
    <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>
<div class="share">

</div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" />
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: "48b3df0bf4ba1743e0a3",
    clientSecret: "4cf1e76de9e18b9ad0def477c36ab22059b152c8",
    repo: "ubuntuvim.github.io", // 博客仓库地址
    owner: "ubuntuvim", // github 用户名
    admin: ["ubuntuvim"], // github 用户名
    perPage: 20,
    id: location.pathname.slice(0, 50), // 查找 issus 的条件，后面将对 id 有针对逻辑
    title: 'Spring后置处理器',
    body: "🚀 " + location.href + "\n\n欢迎通过 issues 留言 ，互相交流学习😊", // 初始化后，issues 的内容
  });
  gitalk.render("gitalk-container");
</script>


    </div>

    

  </div>

  <a href="#" class="return-top">回到顶部</a>
  
  <footer class="footer text-center">
    <div id="bottom-inner">
        <a class="bottom-item" href="https://github.com/ubuntuvim" target="_blank">GitHub</a> |
        <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a>
    </div>
</footer>


  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>


<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

  
  <!-- scripts list from theme config.yml -->
  
    <script src="/js/zepto.min.js"></script>
  


<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



  
</body>
</html>
